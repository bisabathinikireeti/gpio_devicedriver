Constructor overloading allows a class to have multiple constructors with different parameter lists. This lets you initialize objects in different ways depending on what data you have available.
The compiler determines which constructor to call based on the number and type of arguments you pass when creating the object.
Simple Example: A "Room" Class
In this example, we can initialize a room by providing nothing (defaults), just the length, or both length and breadth.
cpp
#include <iostream>
using namespace std;

class Room {
public:
    double length;
    double breadth;

    // 1. Default Constructor (No parameters)
    Room() {
        length = 5.0;
        breadth = 4.0;
    }

    // 2. Overloaded Constructor (One parameter)
    Room(double l) {
        length = l;
        breadth = 4.0;
    }

    // 3. Overloaded Constructor (Two parameters)
    Room(double l, double b) {
        length = l;
        breadth = b;
    }

    void calculateArea() {
        cout << "Area: " << length * breadth << endl;
    }
};

int main() {
    // Calls Constructor 1
    Room r1; 
    
    // Calls Constructor 2
    Room r2(10.0); 
    
    // Calls Constructor 3
    Room r3(10.0, 8.0); 

    cout << "Room 1 "; r1.calculateArea();
    cout << "Room 2 "; r2.calculateArea();
    cout << "Room 3 "; r3.calculateArea();

    return 0;
}
Use code with caution.

Why use it?
Flexibility: You don't always have all the data upfront. Overloading lets you set "safe" defaults for missing values.
Readability: It makes object creation intuitive without needing separate initialization functions like initRoomWithLength().



member intiliser list//
Member Initializer Lists are the "pro" way to write constructors in C++. Instead of assigning values inside the { } body, you initialize them before the constructor even starts. This is faster because it avoids creating a "garbage" value and then overwriting it.
The Efficient Way
Here is the previous Room example rewritten using initializer lists. Notice the syntax: Constructor() : member1(value), member2(value) { }.
cpp
#include <iostream>
using namespace std;

class Room {
public:
    double length;
    double breadth;

    // 1. Default: Initializes length to 5 and breadth to 4
    Room() : length(5.0), breadth(4.0) {}

    // 2. One Param: Initializes length with 'l', breadth to default 4
    Room(double l) : length(l), breadth(4.0) {}

    // 3. Two Params: Initializes both using the passed arguments
    Room(double l, double b) : length(l), breadth(b) {}

    void calculateArea() {
        cout << "Area: " << length * breadth << endl;
    }
};

int main() {
    Room r1;            // Area: 20
    Room r2(10.0);      // Area: 40
    Room r3(10.0, 8.0); // Area: 80

    r1.calculateArea();
    r2.calculateArea();
    r3.calculateArea();

    return 0;
}
Use code with caution.

Why this is better:
Performance: It initializes the variables directly. Assigning inside the {} is technically an "assignment," not an "initialization."
Required for const: If your class has const members or references, you must use an initializer list because they cannot be assigned values later in the body.
Cleaner Code: It keeps the constructor body empty or reserved for actual logic, while the setup happens in the header.
Pro-tip: You can also use Default Parameter Values to do all of the above with just one constructor! Want to see how to merge all three of those constructors into one?
AI responses may include mistakes. For financial advice, consult a professional. Learn more



ok
Using Default Parameter Values, you can replace multiple overloaded constructors with a single, highly flexible one. If the user doesn't provide a value, the compiler automatically plugs in your "default" choice.
The "All-in-One" Constructor
This single constructor does the job of all three from the previous examples:
cpp
#include <iostream>
using namespace std;

class Room {
public:
    double length;
    double breadth;

    // One constructor to rule them all!
    // If 'l' or 'b' aren't provided, they default to 5.0 and 4.0
    Room(double l = 5.0, double b = 4.0) : length(l), breadth(b) {
        cout << "Constructor called with L:" << length << " B:" << breadth << endl;
    }

    void calculateArea() {
        cout << "Area: " << length * breadth << "\n" << endl;
    }
};

int main() {
    // 1. Uses both defaults (5.0, 4.0)
    Room r1; 
    r1.calculateArea();
    
    // 2. Uses provided length, defaults breadth (10.0, 4.0)
    Room r2(10.0); 
    r2.calculateArea();
    
    // 3. Uses both provided values (10.0, 8.0)
    Room r3(10.0, 8.0); 
    r3.calculateArea();

    return 0;
}
Use code with caution.

Important Rules:
Right-to-Left: Default values must be assigned from right to left in the parameter list. You can't have Room(double l = 5.0, double b)—the compiler wouldn't know which one you're skipping.
Ambiguity: If you have a default constructor Room() AND a constructor with all default parameters Room(double l = 5.0), the compiler will get confused (Ambiguity Error) because it won't know which one to pick for Room r1. Use one or the other, not both!
Should we move on to Destructors, or do you want to try a mini-coding challenge to test what you've learned?



op for above code
When you run the "All-in-One" constructor code provided above, the output will look like this:
text
Constructor called with L:5 B:4
Area: 20

Constructor called with L:10 B:4
Area: 40

Constructor called with L:10 B:8
Area: 80
Use code with caution.

Breakdown of the logic:
Room r1; → No values passed. It uses both default values (
).
Room r2(10.0); → One value passed. It assigns 10.0 to the first parameter (l) and uses the default for the second (
).
Room r3(10.0, 8.0); → Two values passed. It ignores both defaults and uses the inputs (
).
