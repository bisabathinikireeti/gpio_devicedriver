Good question üëç Kireeti.
This is one of the most important OOP concepts in C++. I will explain it step-by-step in very simple language.

1Ô∏è‚É£ What is Runtime Polymorphism?

We already saw compile-time polymorphism.

Type	Decision Time
Compile-time	During compilation
Runtime	During program execution

üëâ Runtime polymorphism means the function to execute is decided while the program is running.

It is also called:

Late Binding

Dynamic Polymorphism

2Ô∏è‚É£ How Runtime Polymorphism is Achieved

It is implemented using:

Function Overriding

Virtual Functions

Base class pointer + Derived class object

All three together create runtime polymorphism.

3Ô∏è‚É£ Function Overriding
Definition

Function overriding happens when:

A derived class defines a function

That already exists in the base class

With the same name and parameters

Then the base class function is overridden.

Example Concept

Base class:

display()

Derived class:

display()

Same function name ‚Üí Derived class replaces base class behavior.

4Ô∏è‚É£ Virtual Function

A virtual function tells the compiler:

"Do not decide which function to call now. Decide it at runtime."

It is declared using the keyword:

virtual

Example:

virtual void display();

Without virtual, runtime polymorphism will not work.

5Ô∏è‚É£ Now Let's Understand Your Code
Base Class
class Base {
public:

    virtual void display() {
        cout << "Base class function";
    }
};

Here:

display()

is declared virtual.

This means:

The function can be overridden in derived classes.

Derived Class
class Derived : public Base {
public:

    void display() override {
        cout << "Derived class function";
    }
};

Here the derived class overrides the base class function.

So now:

Class	display()
Base	Base class function
Derived	Derived class function
6Ô∏è‚É£ Important Line in Main Function
Base* basePtr;

This means:

basePtr is a pointer of Base class
Creating Derived Object
Derived derivedObj;

Now we have an object of derived class.

Base Pointer Pointing to Derived Object
basePtr = &derivedObj;

This means:

Base pointer ‚Üí Derived object

This is called:

Upcasting
Base* ‚Üí Derived object
7Ô∏è‚É£ Calling the Function
basePtr->display();

Now the big question:

Which function will run?

Base display()
OR
Derived display()

Because pointer type is Base.

8Ô∏è‚É£ What Happens Without Virtual

If virtual was not used:

Base class function

would run.

Because compiler checks pointer type.

9Ô∏è‚É£ What Happens With Virtual

Because we used:

virtual

C++ checks actual object type at runtime.

Object type:

Derived

So it runs:

Derived class function

Output:

Derived class function
üîü Why This Happens

Because C++ uses something called:

Dynamic Binding

The function call is resolved during runtime, not compilation.

1Ô∏è‚É£1Ô∏è‚É£ Important Concept: vtable (Interview Topic)

When we declare a virtual function, C++ creates:

Virtual Table (vtable)

Each class has a table storing addresses of virtual functions.

Example concept:

Base vtable ‚Üí display()
Derived vtable ‚Üí display()

When program runs:

basePtr ‚Üí derivedObj

C++ checks the derived vtable and calls:

Derived display()
1Ô∏è‚É£2Ô∏è‚É£ Why Use Runtime Polymorphism?

It is useful when:

We don't know which object type will be used.

Example:

Shape
   |
   |---- Circle
   |---- Rectangle
   |---- Triangle

All shapes have:

draw()

But each shape draws differently.

Using runtime polymorphism:

Shape* s;
s->draw();

Correct function will run automatically.

1Ô∏è‚É£3Ô∏è‚É£ Important Rules of Function Overriding

1Ô∏è‚É£ Function name must be same

2Ô∏è‚É£ Parameters must be same

3Ô∏è‚É£ Must use inheritance

4Ô∏è‚É£ Base function should be virtual

1Ô∏è‚É£4Ô∏è‚É£ override Keyword

You saw this:

void display() override

This keyword:

‚úî Confirms the function is overriding
‚úî Prevents mistakes

Example error:

display(int)

Then compiler will detect mismatch.

1Ô∏è‚É£5Ô∏è‚É£ Base Pointer to Derived Object (Important)

This is the core rule of runtime polymorphism.

Base* ptr;
Derived obj;

ptr = &obj;

Then calling virtual function:

ptr->function();

will call derived version.

1Ô∏è‚É£6Ô∏è‚É£ Difference: Overloading vs Overriding
Feature	Overloading	Overriding
Class	Same class	Base + Derived
Parameters	Different	Same
Polymorphism	Compile time	Runtime
Keyword	No virtual needed	virtual required
1Ô∏è‚É£7Ô∏è‚É£ Pure Virtual Function (Very Important Topic)

Sometimes base class only declares function.

Example:

virtual void display() = 0;

This is called:

Pure Virtual Function

Class becomes:

Abstract Class

Meaning:

You cannot create object of this class.

Example:

Shape

You cannot create a general shape.

But you can create:

Circle
Rectangle
Triangle
1Ô∏è‚É£8Ô∏è‚É£ Virtual Destructor (Advanced but Important)

If base class has virtual functions, destructor should also be virtual.

Example:

virtual ~Base() {}

This ensures proper cleanup.

1Ô∏è‚É£9Ô∏è‚É£ Short Summary
Compile-Time Polymorphism

Function overloading

Operator overloading

Decided at compile time

Runtime Polymorphism

Function overriding

Uses virtual functions

Base pointer ‚Üí derived object

Function decided at runtime

‚≠ê One Line Memory Trick
Overloading ‚Üí Compile Time
Overriding ‚Üí Runtime


example program

#include <bits/stdc++.h>
using namespace std;

class Base {
public:

    // Virtual function
    virtual void display() {
        cout << "Base class function";
    }
};

class Derived : public Base {
public:

    // Overriding the base class function
    void display() override {
        cout << "Derived class function";
    }
};

int main() {
    
    // Creating a pointer of type Base
    Base* basePtr;
    
    // Creating an object of Derived class
    Derived derivedObj;

    // Pointing base class pointer to 
    // derived class object
    basePtr = &derivedObj;
    
    // Calling the display function 
    // using base class pointer
    basePtr->display();
    return 0;
}


