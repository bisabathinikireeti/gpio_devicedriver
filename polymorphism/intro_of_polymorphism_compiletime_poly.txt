.

ğŸ”¹ What is Polymorphism?

Poly = many
Morphism = forms

ğŸ‘‰ So, Polymorphism means â€œmany forms.â€

In C++, it means:

The same name (function or operator) can behave differently in different situations.

ğŸ”¹ Types of Polymorphism in C++

There are mainly two types:

Compile-Time Polymorphism (Static / Early Binding)

Run-Time Polymorphism (Dynamic / Late Binding)

Your example is about Compile-Time Polymorphism, so letâ€™s focus on that.

âœ… 1. Compile-Time Polymorphism

Here, the decision is made at compile time (before program runs).

The compiler decides:

Which function to call

Based on number or type of arguments

It is achieved using:

âœ” Function Overloading

âœ” Operator Overloading

ğŸ”¹ A. Function Overloading
ğŸ‘‰ What is Function Overloading?

When:

Two or more functions

Have the same name

But different parameters

That is called Function Overloading.

You can overload by:

Changing number of arguments

Changing type of arguments

ğŸ”¹ Now Letâ€™s Understand Your Code
class Geeks {
public:
    
    void add(int a, int b) {
        cout << "Integer Sum = " << a + b << endl;
    }
    
    void add(double a, double b) {
        cout << "Float Sum = " << a + b << endl;
    }
};

Here:

We have two functions with same name â†’ add()

But difference is:

Function	Parameter Type
add(int, int)	Integer values
add(double, double)	Decimal values

So this is Function Overloading.

ğŸ”¹ What Happens in main()?
Geeks gfg;

gfg.add(10, 2);

Here:

10 and 2 are integers

So compiler calls:

void add(int a, int b)

Output:

Integer Sum = 12

Next:

gfg.add(5.3, 6.2);

Here:

5.3 and 6.2 are double values

So compiler calls:

void add(double a, double b)

Output:

Float Sum = 11.5
ğŸ”¹ Why is this Compile-Time Polymorphism?

Because:

ğŸ‘‰ The compiler decides which function to call before execution
ğŸ‘‰ It checks argument types during compilation

No confusion at runtime.

ğŸ”¹ Simple Real-Life Example

Think of a calculator:

If you enter 2 and 3 â†’ it does integer addition

If you enter 2.5 and 3.7 â†’ it does decimal addition

Same button (+)
Different behavior depending on input

That is Polymorphism.

ğŸ”¹ Important Rule

You cannot overload only by changing return type.

âŒ Wrong:

int add(int a, int b);
double add(int a, int b);

Because parameters are same â†’ compiler gets confused.

ğŸ”¹ Short Summary (Easy Revision)

âœ” Polymorphism = One name, many forms
âœ” Compile-time polymorphism = Decided at compile time
âœ” Achieved using:

Function overloading

Operator overloading
âœ” Function overloading = Same function name, different parameters



function overloading
#include <bits/stdc++.h>
using namespace std;

class Geeks {
public:
    
    // Function to add two integers
    void add(int a, int b) {
        cout << "Integer Sum = " << a + b
        << endl;
    }
    
    // Function to add two floating point values
    void add(double a, double b) {
        cout << "Float Sum = " << a + b
        << endl ;
    }
};

int main() {
    Geeks gfg;
    
    // add() called with int values
    gfg.add(10, 2);

    // add() called with double value
    gfg.add(5.3, 6.2);

    return 0;
}



operator overloading 



Good ğŸ‘ Kireeti â€” now letâ€™s understand Operator Overloading in a very clear and simple way.

You already understood function overloading.
Now this is the next level.

ğŸ”¹ What is Operator Overloading?

Normally, operators like:

+  -  *  /  <<  >>

work only for basic data types like:

int

float

double

char

Example:

int a = 5, b = 3;
cout << a + b;   // Works

But if you create your own class like:

class Complex { ... };

Then this will NOT work by default:

Complex c1, c2;
c1 + c2;   // âŒ Error (compiler doesn't know what to do)

ğŸ‘‰ Because compiler does not know:
"How to add two Complex numbers?"

So we define it ourselves.

That is called Operator Overloading.

ğŸ”¹ Simple Definition

Operator overloading means giving special meaning to operators when used with user-defined classes.

ğŸ”¹ Why We Need It?

Without operator overloading:

c3 = c1.add(c2);   // normal function style

With operator overloading:

c3 = c1 + c2;      // cleaner and natural

It makes code:
âœ” Cleaner
âœ” More readable
âœ” More like real mathematics

ğŸ”¹ Understanding Your Example
Complex Number

A complex number looks like:

10 + i5

It has:

Real part

Imaginary part

ğŸ”¹ Step-by-Step Code Explanation
class Complex {
public:
    int real, imag;

We created a class with:

real part

imaginary part

Constructor
Complex(int r, int i) : real(r), imag(i) {}

This initializes values.

Example:

Complex c1(10, 5);

Means:

real = 10
imag = 5
ğŸ”¹ Overloading the + Operator
Complex operator+(const Complex& obj)

This line is very important.

Letâ€™s break it:

Part	Meaning
Complex	Return type
operator+	We are overloading +
const Complex& obj	Object passed as parameter
What Happens Here?

When you write:

c1 + c2;

Internally it becomes:

c1.operator+(c2);
Inside Function
return Complex(real + obj.real,
               imag + obj.imag);

It adds:

real parts

imaginary parts

Example:

c1 = 10 + i5
c2 = 2 + i4

Addition:

(10 + 2) + i(5 + 4)
= 12 + i9

Output:

12 + i9
ğŸ”¹ Important Concept
Why use const Complex& obj?

Instead of:

Complex obj

We use:

const Complex& obj

Because:

âœ” Avoids copying object (faster)
âœ” Prevents modification (safe)
âœ” Saves memory

This is good practice (especially important in interviews).

ğŸ”¹ How Operator Overloading Works Internally

When you write:

Complex c3 = c1 + c2;

Compiler converts it to:

Complex c3 = c1.operator+(c2);

So operator overloading is just a special function.

ğŸ”¹ Operators That Can Be Overloaded

Most operators can be overloaded:

+  -  *  /  
== != < >  
++ --  
[]  
<< >>
ğŸ”¹ Operators That CANNOT Be Overloaded

These are fundamental to C++:

::   (scope resolution)
.    (dot operator)
.*  
?:   (ternary)
sizeof

They cannot be overloaded because:

ğŸ‘‰ They control core language behavior
ğŸ‘‰ Changing them would break compiler logic

ğŸ”¹ Types of Operator Overloading

There are 2 ways:

1ï¸âƒ£ Member Function (like your example)
Complex operator+(const Complex& obj);

Left side object calls function.

2ï¸âƒ£ Friend Function (used when left side is not object)

Example:

friend Complex operator+(Complex c1, Complex c2);

Used when operator needs access to private members.

ğŸ”¹ Overloading << (Very Important)

You use:

cout << c3;

But normally it wonâ€™t work for objects.

We overload it like:

friend ostream& operator<<(ostream& out, const Complex& c) {
    out << c.real << " + i" << c.imag;
    return out;
}

Then we can write:

cout << c3;

Very useful concept.

ğŸ”¹ Difference: Function Overloading vs Operator Overloading
Function Overloading	Operator Overloading
Same function name	Same operator symbol
Different parameters	Different operand types
Example: add()	Example: +
ğŸ”¹ Compile-Time or Run-Time?

Operator overloading is:

ğŸ‘‰ Compile-Time Polymorphism
ğŸ‘‰ Because compiler decides which operator function to call.

ğŸ”¹ Important Rules

You cannot create new operators.

You cannot change operator precedence.

You cannot change number of operands.

At least one operand must be user-defined type.

ğŸ”¹ Real-Life Example

Think about:

5 + 3  â†’ integer addition
"Hi" + "Hello" â†’ string concatenation

Same operator (+)
Different behavior

That is operator overloading.

#include <iostream>
using namespace std;

class Complex {
public:
    int real, imag;
    
    Complex(int r, int i) :
    real(r), imag(i) {}

    // Overloading the '+' operator
    Complex operator+(const Complex& obj) {
        return Complex(real + obj.real,
        imag + obj.imag);
    }
};

int main() {
    Complex c1(10, 5), c2(2, 4);
    
    // Adding c1 and c2 using + operator
    Complex c3 = c1 + c2;  
    cout << c3.real << " + i" << c3.imag;
    return 0;
}



